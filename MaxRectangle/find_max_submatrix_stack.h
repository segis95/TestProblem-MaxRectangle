// Данное решение основано на следющей идее. Для каждой позиции очередной строки матрицы подсчитаем
// число подряд идущих единиц сверху, заканчивающихся в этой позиции. Если в данной позиции матрицы
// находится нуль, то это число равно нулю. Подсчитав данное количество, можно воспользоваться
// следующими наблюдениями:
//
// - Если число единиц над данной позицией меньше, чем над предыдущей, то подматрицу высотой с
//   предыдущий столбец нельзя продолжить вправо;
// - Однако вправо можно продолжить матрицу высоты как в данной позиции, начинающуюся в предыдущей
//   позиции
//
// Пример:
// Пусть высоты столбцов равны 5 и 3. Тогда из позиции столбца высоты 5 нельзя продолжить вправо
// матрицу высоты 5, но можно продолжить матрицу высоты 3 (столбец 3 прерывает серию столбца 5).
// Будем хранить такие "непрерванные" серии вместе с их начальными позициями в стеке и обновлять
// стек по мере продвижения по строке и прерывания серий.
//
// Сложность решения: O(m*n) по времени, поскольку каждая позиция, попавшая в стек, оттуда удаляется
// и больше обратно не попадает. Решение также требует O(n) дополнительной памяти.

#pragma once
#include "data_structures.h"

Rectangle find_max_submatrix_stack(std::vector<std::vector<bool>>& matrix);
